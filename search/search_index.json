{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"VkLite \u2013 A Modern Vulkan Renderer","text":"<p>VkLite is a lightweight yet fully functional Vulkan-based renderer developed from first principles. It serves as both a practical implementation and a pedagogical guide for building a modern real-time graphics engine. While the material is approachable for beginners, it is also structured to scale with intermediate-level learners who wish to develop a deeper understanding of graphics programming using Vulkan and C++.</p> <p>The renderer is written using the C++20 standard, but modern language features have been deliberately limited to ensure clarity, portability, and accessibility. The codebase is organized with clean abstractions and modular architecture, making it suitable as a starting point for research projects, educational tools, or real-time games.</p>"},{"location":"#target-audience","title":"Target Audience","text":"<p>This material is designed for:</p> <ul> <li>Undergraduate and graduate students studying computer graphics or game development.</li> <li>Beginners with a strong interest in graphics programming who are willing to engage with low-level APIs.</li> <li>Intermediate developers familiar with OpenGL, DirectX, or Metal seeking a transition into Vulkan.</li> <li>Researchers and hobbyists building custom engines or interactive simulation environments.</li> </ul> <p>A prior understanding of basic C++ programming and linear algebra is expected. No prior Vulkan experience is required.</p>"},{"location":"#learning-outcomes","title":"Learning Outcomes","text":"<p>Upon completing this material, the reader will be able to:</p> <ul> <li>Initialize and manage Vulkan instances, devices, and swapchains.</li> <li>Understand and implement GPU-side synchronization, memory barriers, and descriptor sets.</li> <li>Construct a fully functional render loop suitable for real-time applications.</li> <li>Design and compile compute and graphics pipelines.</li> <li>Integrate runtime tooling using Dear ImGui.</li> <li>Manage GPU resources and memory efficiently.</li> <li>Build a minimal scene graph with spatial transforms and camera systems.</li> <li>Load and sample images and construct a material abstraction layer.</li> <li>Implement a basic physically based rendering (PBR) system using real-time lighting models.</li> </ul> <p>These outcomes are intended to not only teach Vulkan usage but also provide foundational knowledge for engine architecture and GPU programming practices.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Before beginning, readers should ensure the following requirements are met:</p> <ul> <li>A system with a Vulkan-compatible GPU and up-to-date drivers.</li> <li>A C++20-compatible compiler (GCC, Clang, or MSVC).</li> <li>Development tools: Git, CMake, and a code editor or IDE (e.g., Visual Studio Code, CLion, or Visual Studio).</li> <li>Familiarity with:<ul> <li>Programming fundamentals in C++</li> <li>Linear algebra (vectors, matrices, coordinate systems)</li> <li>Compilation and linking workflows in modern C++</li> </ul> </li> </ul> <p>No prior graphics API experience (e.g., OpenGL or DirectX) is required but will be helpful.</p>"},{"location":"#structure-of-the-course","title":"Structure of the Course","text":"<p>The material is organized into progressive chapters. Each chapter builds upon concepts introduced previously and concludes with practical implementations in code. The structure is as follows:</p> <ul> <li> <p>Introduction to Vulkan   Overview of the Vulkan API, its design philosophy, and how it differs from older graphics APIs.</p> </li> <li> <p>Project Setup   Preparing the build system using CMake, acquiring dependencies, and establishing a development environment.</p> </li> <li> <p>Render Loop   Constructing the per-frame rendering process using Vulkan command buffers, semaphores, and fences.</p> </li> <li> <p>Compute Pipeline   Implementing compute shaders for tasks such as simulation, post-processing, and general GPU compute.</p> </li> <li> <p>ImGui Integration   Embedding Dear ImGui for runtime UI tools, debug panels, and in-engine inspectors.</p> </li> <li> <p>GPU Memory Management   Exploring allocation strategies and abstraction layers for efficient buffer and image memory usage.</p> </li> <li> <p>Graphics Pipeline   Creating programmable graphics pipelines with support for dynamic states, shader modules, and vertex input.</p> </li> <li> <p>Scene Graph, Transforms, and Camera   Developing a hierarchical object system with support for spatial transforms and multiple camera views.</p> </li> <li> <p>Textures and Materials   Loading texture data from files, sampling in shaders, and associating textures with material parameters.</p> </li> <li> <p>Physically Based Rendering   Implementing PBR with support for metal/roughness workflows and real-time lighting.</p> </li> </ul>"},{"location":"#features-of-vklite","title":"Features of VkLite","text":"<p>The VkLite renderer provides the following features:</p> <ul> <li>Clean, modular C++ implementation with minimal dependencies.</li> <li>Abstractions over Vulkan resources such as pipelines, buffers, descriptor sets, and shaders.</li> <li>Configurable render loop with support for multiple frames in flight.</li> <li>Integration with ImGui for user interface and runtime tools.</li> <li>Compute shader support for simulation or general-purpose GPU workloads.</li> <li>Physically based rendering using real-time BRDFs and material systems.</li> <li>Extensible architecture suitable for integration with ECS frameworks or game logic.</li> </ul>"},{"location":"#supplementary-resources","title":"Supplementary Resources","text":"<p>The following references are recommended for further reading:</p> <ul> <li>Vulkan API Reference Documentation</li> <li>Vulkan Specification (Khronos Group)</li> </ul>"},{"location":"#community-and-contributions","title":"Community and Contributions","text":"<ul> <li>Source Code: https://github.com/Rounak-Paul/vklite</li> <li>Issue Tracker: Use GitHub Issues to report bugs, request features, or ask implementation-related questions.</li> <li>Community Discussion: A dedicated community discussion platform (e.g., Discord or GitHub Discussions) may be added in future.</li> </ul> <p>Contributions via pull requests or external tutorials based on this framework are welcome.</p>"},{"location":"#license","title":"License","text":"<p>This course and the associated source code are licensed under the Apache 2.0 License, allowing free use for academic, educational, and commercial purposes. Proper attribution to the original author is required.</p> <p>To begin, continue to Chapter 00 \u2013 Introduction to Vulkan.</p>"},{"location":"00/Introduction/","title":"vulkan introduction","text":"<p>Computer graphics has always lived at the intersection of science and imagination. From the pixelated simplicity of Pong in 1970s to the photorealism of modern video games and cinematic visual effects, our tools for drawing to the screen have grown astonishingly powerful. But behind every realistic explosion, glowing sunset, or procedurally generated planet lies a mountain of computation \u2014 and a carefully orchestrated pipeline between software and hardware.</p> <p>To understand Vulkan \u2014 a modern graphics API designed for maximum performance and control \u2014 we must first understand the journey that brought us here. The story of Vulkan is not just about a new tool, but about the evolution of the very way we think about rendering images with computers.</p>"},{"location":"00/Introduction/#in-the-beginning-the-age-of-fixed-function-pipelines","title":"In the Beginning: The Age of Fixed-Function Pipelines","text":"<p>In the early days of computer graphics, the process of drawing 3D scenes was both limited and rigid. Graphics hardware offered a fixed-function pipeline \u2014 a set of hardcoded stages that transformed 3D geometry into a 2D image. You could translate, rotate, and scale objects. You could define how they were lit using a few built-in lights. You could map textures onto surfaces. But all of this had to be done using predefined operations set by the GPU\u2019s designers.</p> <p>Developers were passengers in this system. They could steer within narrow lanes but had little freedom to rewrite the rules of the road.</p> <p>This pipeline made many things easy, which was its strength \u2014 but it was also its weakness. As games and simulations grew more complex and ambitious, developers needed to create their own lighting models, their own shading logic, their own effects. And the fixed pipeline simply couldn\u2019t bend that far.</p> <p>The industry was ready for a transformation.</p>"},{"location":"00/Introduction/#a-turning-point-programmable-shaders","title":"A Turning Point: Programmable Shaders","text":"<p>The breakthrough came in the early 2000s when GPU manufacturers began to roll out programmable hardware. No longer were developers restricted to built-in lighting and shading rules. They could now write their own small programs \u2014 called shaders \u2014 to define exactly how each vertex and pixel should behave.</p> <p>This revolution began in earnest with ATI\u2019s Radeon 9700 (R300) in 2002 \u2014 the first fully programmable GPU. With it came support for vertex and pixel shaders, and the dawn of the programmable graphics pipeline.</p> <p>Suddenly, artists and engineers could implement per-pixel lighting, normal mapping, custom fog effects, and more. Realism and creativity flourished. And as GPUs became more powerful, so did the ambition of those writing code for them. A new generation of rendering engines was born, more cinematic and immersive than ever before.</p> <p>But there was still one problem: the software interface.</p>"},{"location":"00/Introduction/#the-reign-of-opengl","title":"The Reign of OpenGL","text":"<p>To access GPU functionality, developers relied on graphics APIs \u2014 software layers that let applications communicate with the GPU. One of the most influential APIs was OpenGL, originally developed by Silicon Graphics in the early 1990s. OpenGL offered a cross-platform interface to 3D rendering and eventually evolved to support programmable shaders and more advanced GPU features.</p> <p>For many years, OpenGL reigned supreme in academic research, professional graphics software, and game engines alike. It was powerful, widely supported, and reasonably easy to use. But as GPUs became more complex and computers moved to multi-core architectures, OpenGL\u2019s original design began to show cracks.</p> <p>Much of OpenGL\u2019s behavior was implicitly managed by the driver, the software layer provided by GPU vendors. This abstraction was useful for beginners but became a liability for professionals. Performance could vary dramatically across vendors and platforms. Worse, OpenGL\u2019s global state machine model made it difficult \u2014 and often impossible \u2014 to use multiple CPU threads efficiently. Developers were left guessing how the driver would behave and were often forced to write code defensively, targeting the lowest common denominator of performance and compatibility.</p> <p>In a world moving toward low-latency VR, ray tracing, and real-time physics, that just wasn\u2019t good enough anymore.</p>"},{"location":"00/Introduction/#enter-the-modern-graphics-api","title":"Enter the Modern Graphics API","text":"<p>Around 2014, a new philosophy began to take root in the graphics community. The idea was simple: what if APIs were explicit, giving developers full control over memory, synchronization, and resource usage? What if we stripped away decades of abstraction and gave professionals the tools to fully exploit modern hardware?</p> <p>This was the vision behind a new class of low-level graphics APIs \u2014 designed not to shield developers from complexity, but to expose it in a structured, predictable way.</p> <p>These APIs included: - Direct3D 12, Microsoft\u2019s low-level API for Windows. - Metal, Apple\u2019s graphics API for iOS and macOS. - And of course, Vulkan, a bold new cross-platform standard from the Khronos Group.</p> <p>These APIs spoke the language of modern graphics: multi-threading, GPU parallelism, explicit resource control, and deterministic performance.</p> <p>They also shifted responsibility from the driver to the developer. That meant more work \u2014 but also more power.</p>"},{"location":"00/Introduction/#what-is-vulkan","title":"What Is Vulkan?","text":"<p>Vulkan is the result of this evolution \u2014 a modern, low-overhead, cross-platform graphics and compute API that gives developers unprecedented control over the GPU. Released in 2016 by the Khronos Group (the same consortium that manages OpenGL), Vulkan was designed for performance-critical applications on a wide variety of platforms: Windows, Linux, Android, and even macOS (via a translation layer called MoltenVK).</p> <p>What makes Vulkan different? - Explicit design: You manage GPU memory, synchronization, and resource lifetimes yourself. No more driver guesswork. - Multi-threading support: Vulkan\u2019s architecture makes it possible to generate and submit commands from multiple CPU threads in parallel \u2014 ideal for modern processors. - Cross-platform consistency: Vulkan offers the same core behavior across platforms, reducing fragmentation and vendor-specific hacks. - Unified compute and graphics: You can perform general-purpose GPU tasks (like physics or AI) and rendering with the same API.</p> <p>But Vulkan is not for the faint of heart. It is verbose. It is strict. It demands precision. And it shifts the burden of correctness to you, the developer.</p> <p>Yet for all that, it gives something back that few APIs can: predictability. If your Vulkan application runs slowly, it\u2019s likely your fault \u2014 not the driver\u2019s. And that is empowering.</p> <p>Next Vulkan SDK</p>"},{"location":"01/Instance_Creation/","title":"Creating a Vulkan Instance","text":"<p>The first step in any Vulkan application is to create a Vulkan instance. The instance represents the connection between your application and the Vulkan library. It is required before you can query for physical devices, create surfaces, or perform any rendering operations.</p> <p>This chapter will guide you through the process of creating and destroying a Vulkan instance in C++ using the Vulkan SDK.</p>"},{"location":"01/Instance_Creation/#update-the-header","title":"Update the Header","text":"<p>Add the Vulkan headers and a member to hold the instance handle in <code>vklite.h</code>:</p> <pre><code>#include &lt;vulkan/vulkan.h&gt;\n\nstruct Context {\n    VkInstance instance = VK_NULL_HANDLE;\n    // ...existing code...\n};\n</code></pre>"},{"location":"01/Instance_Creation/#create-the-instance-in-c","title":"Create the Instance in C++","text":"<p>In <code>vklite.cpp</code>, update the <code>initialize</code> and <code>shutdown</code> methods to:</p> <ol> <li>Query the Vulkan loader for the maximum supported API version and require at least 1.3.</li> <li>Query required instance extensions from GLFW, and add the portability extension for macOS.</li> <li>Pass these extensions to the Vulkan instance creation struct.</li> </ol> <pre><code>#include &lt;GLFW/glfw3.h&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\n// ...\n\n// Query Vulkan loader for supported API version\nuint32_t apiVersion = 0;\nif (vkEnumerateInstanceVersion) {\n    vkEnumerateInstanceVersion(&amp;apiVersion);\n} else {\n    apiVersion = VK_API_VERSION_1_0;\n}\nif (apiVersion &lt; VK_API_VERSION_1_3) {\n    std::cerr &lt;&lt; \"Vulkan 1.3 or higher is required!\" &lt;&lt; std::endl;\n    return false;\n}\n\n// Query required extensions from GLFW\nif (!glfwInit()) {\n    std::cerr &lt;&lt; \"Failed to initialize GLFW!\" &lt;&lt; std::endl;\n    return false;\n}\nuint32_t glfwExtensionCount = 0;\nconst char** glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount);\nstd::vector&lt;const char*&gt; extensions(glfwExtensions, glfwExtensions + glfwExtensionCount);\n\n#if defined(VKLITE_PLAT_MAC)\n// Add portability enumeration extension for macOS\nextensions.push_back(\"VK_KHR_portability_enumeration\");\n#endif\n\nVkApplicationInfo appInfo{};\nappInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;\nappInfo.pApplicationName = appName.c_str();\nappInfo.applicationVersion = VK_MAKE_VERSION(1, 3, 0);\nappInfo.pEngineName = \"vklite\";\nappInfo.engineVersion = VK_MAKE_VERSION(1, 3, 0);\nappInfo.apiVersion = VK_API_VERSION_1_3;\n\nVkInstanceCreateInfo createInfo{};\ncreateInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;\ncreateInfo.pApplicationInfo = &amp;appInfo;\ncreateInfo.enabledExtensionCount = static_cast&lt;uint32_t&gt;(extensions.size());\ncreateInfo.ppEnabledExtensionNames = extensions.data();\n#if defined(VKLITE_PLAT_MAC)\ncreateInfo.flags |= VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR;\n#endif\n\nVkResult result = vkCreateInstance(&amp;createInfo, nullptr, &amp;instance);\nif (result != VK_SUCCESS) {\n    std::cerr &lt;&lt; \"Failed to create Vulkan instance!\\n\";\n    instance = VK_NULL_HANDLE;\n    return false;\n}\n</code></pre> <p>And in <code>shutdown</code>:</p> <pre><code>if (instance != VK_NULL_HANDLE) {\n    vkDestroyInstance(instance, nullptr);\n    instance = VK_NULL_HANDLE;\n}\n</code></pre>"},{"location":"01/Instance_Creation/#minimal-working-example","title":"Minimal Working Example","text":"<p>After these changes, your <code>Context</code> will create and destroy a Vulkan instance. You can now build and run your project to verify that instance creation succeeds (no validation layers or extensions are enabled yet).</p> <p>Next Window Creation</p>"},{"location":"01/Project_Setup/","title":"Setting Up the Project Structure","text":"<p>With the Vulkan SDK installed and verified (see previous chapter), we are ready to set up our C++ project for Vulkan development. This chapter will guide you through creating a clean, modular project structure using CMake, and configuring it to build against the Vulkan SDK.</p>"},{"location":"01/Project_Setup/#create-the-folder-structure","title":"Create the Folder Structure","text":"<p>Organize your project for clarity and scalability. A recommended structure is:</p> <pre><code>project_root/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 vklite/\n\u2502   \u251c\u2500\u2500 CMakeLists.txt\n\u2502   \u251c\u2500\u2500 include/\n\u2502   \u2502   \u2514\u2500\u2500 vklite.h\n\u2502   \u2514\u2500\u2500 src/\n\u2502       \u2514\u2500\u2500 vklite.cpp\n\u251c\u2500\u2500 sandbox/\n\u2502   \u251c\u2500\u2500 CMakeLists.txt\n\u2502   \u2514\u2500\u2500 src/\n\u2502       \u2514\u2500\u2500 main.cpp\n</code></pre> <p>This separates the core renderer (<code>vklite</code>) from example or test applications (<code>sandbox</code>).</p>"},{"location":"01/Project_Setup/#source-code-for-starter-files","title":"Source Code for Starter Files","text":"<p>Below are the minimal source files to get your project building and running. Copy these into the appropriate locations:</p>"},{"location":"01/Project_Setup/#vkliteincludevkliteh","title":"<code>vklite/include/vklite.h</code>","text":"<pre><code>#pragma once\n\n#include &lt;string&gt;\n\n// Platform macros provided by the build system:\n// - VKLITE_PLAT_WINDOWS (windows)\n// - VKLITE_PLAT_LINUX   (linux / unix)\n// - VKLITE_PLAT_MAC     (apple / macos)\n\nnamespace vklite {\n\nstruct Context {\n    // Initialize creates the Vulkan instance and prepares internal state.\n    // Returns true on success, false on failure.\n    bool initialize(const std::string &amp;appName = \"vklite-app\");\n\n    // Shutdown cleans up Vulkan objects and internal resources.\n    void shutdown();\n};\n\n} // namespace vklite\n</code></pre>"},{"location":"01/Project_Setup/#vklitesrcvklitecpp","title":"<code>vklite/src/vklite.cpp</code>","text":"<pre><code>#include \"vklite.h\"\n#include &lt;iostream&gt;\n\nnamespace vklite {\n\nbool Context::initialize(const std::string &amp;appName){\n    // Initializes Vulkan instance, queries loader version and prepares GLFW.\n    // See the Instance Creation chapter for details on instance flags and\n    // required extensions.\n    return true;\n}\n\nvoid Context::shutdown(){\n    // Clean up Vulkan and windowing resources.\n}\n\n} // namespace vklite\n</code></pre>"},{"location":"01/Project_Setup/#sandboxsrcmaincpp","title":"<code>sandbox/src/main.cpp</code>","text":"<pre><code>#include \"vklite.h\"\n#include &lt;iostream&gt;\n\nint main(){\n    vklite::Context ctx;\n    if(!ctx.initialize(\"sandbox\")){\n        std::cerr &lt;&lt; \"Failed to initialize vklite\\n\";\n        return 1;\n    }\n\n    std::cout &lt;&lt; \"sandbox running...\\n\";\n\n    ctx.shutdown();\n    return 0;\n}\n</code></pre>"},{"location":"01/Project_Setup/#initialize-cmake-build-system","title":"Initialize CMake Build System","text":"<p>At the root, create a <code>CMakeLists.txt</code> to manage the overall build:</p> <pre><code>cmake_minimum_required(VERSION 3.16)\nproject(vklite LANGUAGES CXX)\n\nadd_subdirectory(vklite)\nadd_subdirectory(sandbox)\n</code></pre> <p>Each subdirectory (<code>vklite</code>, <code>sandbox</code>) should have its own <code>CMakeLists.txt</code>.</p>"},{"location":"01/Project_Setup/#configure-vulkan-sdk-in-cmake","title":"Configure Vulkan SDK in CMake","text":"<p>In your <code>vklite/CMakeLists.txt</code>, find and link the Vulkan library:</p> <pre><code>find_package(Vulkan REQUIRED)\n\nadd_library(vklite\n    src/vklite.cpp\n    include/vklite.h\n)\n\ntarget_include_directories(vklite PUBLIC include)\ntarget_link_libraries(vklite PUBLIC Vulkan::Vulkan)\nset_target_properties(vklite PROPERTIES CXX_STANDARD 20)\n</code></pre> <p>This ensures your renderer links against the Vulkan SDK and uses modern C++.</p>"},{"location":"01/Project_Setup/#add-an-example-application","title":"Add an Example Application","text":"<p>In <code>sandbox/CMakeLists.txt</code>:</p> <pre><code>add_executable(sandbox src/main.cpp)\ntarget_link_libraries(sandbox PRIVATE vklite)\nset_target_properties(sandbox PROPERTIES CXX_STANDARD 20)\n</code></pre> <p>This builds a simple application that uses your renderer.</p>"},{"location":"01/Project_Setup/#build-the-project","title":"Build the Project","text":"<p>From the project root, configure and build:</p> <pre><code>cmake -S . -B build\ncmake --build build\n</code></pre> <p>If everything is set up correctly, you should see both the <code>vklite</code> library and the <code>sandbox</code> executable built in the <code>build/</code> directory.</p>"},{"location":"01/Project_Setup/#next-steps","title":"Next Steps","text":"<p>You are now ready to begin implementing Vulkan features in your renderer. The next chapter will guide you through creating the Vulkan instance, the first step in any Vulkan application.</p> <p>Next Instance Creation</p>"},{"location":"01/Vulkan_SDK/","title":"vulkan SDK","text":"<p>Before we can appreciate Vulkan's architectural decisions and design philosophy, we must establish a clear understanding of the hardware and software ecosystem in which it operates. Modern graphics programming exists at the intersection of multiple computational domains, each with its own characteristics, constraints, and capabilities.</p> <p>The terminology we use to describe these systems is not merely academic \u2014 it reflects fundamental differences in how computation is organized, memory is managed, and performance is achieved.</p>"},{"location":"01/Vulkan_SDK/#the-computational-divide-cpu-and-gpu-architectures","title":"The Computational Divide: CPU and GPU Architectures","text":"<p>At the heart of any graphics application lies a fundamental architectural division between two distinct types of processors, each optimized for different computational paradigms.</p> <p>The Central Processing Unit (CPU) represents the traditional model of sequential computation. Built around the principle of executing complex instructions with maximum flexibility, modern CPUs excel at tasks requiring branching logic, unpredictable memory access patterns, and sophisticated control flow. While contemporary CPUs feature multiple cores \u2014 typically ranging from four to dozens \u2014 their design philosophy remains rooted in optimizing single-threaded performance and providing the complex caching hierarchies needed to handle irregular workloads.</p> <p>In the context of graphics programming, we refer to the CPU and its directly accessible memory space as the Host System. This system memory, typically implemented as DDR4 or DDR5 RAM, serves as the primary workspace for application logic, operating system services, and the coordination of graphics operations.</p> <p>The Graphics Processing Unit (GPU), by contrast, embodies a radically different computational philosophy. Where CPUs prioritize flexibility and single-threaded performance, GPUs optimize for massive parallelism and throughput. A modern GPU contains thousands of simple processing cores, each capable of executing the same operation on different data simultaneously \u2014 a model known as SIMD (Single Instruction, Multiple Data) processing.</p> <p>This architectural difference is not merely a matter of scale. GPUs are designed around the assumption that graphics workloads exhibit high data parallelism and regular access patterns. Lighting calculations, texture sampling, and geometric transformations can all be performed on thousands of pixels or vertices simultaneously, making them ideal candidates for GPU acceleration.</p> <p>In Vulkan terminology, the GPU and its associated hardware ecosystem constitute the Device. This distinction is crucial because the Device operates as a semi-autonomous system with its own memory hierarchy, command processing capabilities, and execution model.</p>"},{"location":"01/Vulkan_SDK/#the-memory-boundary-host-and-device-memory-systems","title":"The Memory Boundary: Host and Device Memory Systems","text":"<p>One of the most critical aspects of modern graphics programming is understanding the relationship between different memory systems. The Host System's memory \u2014 accessible directly by the CPU \u2014 exists in a different address space from the Device's memory pool. This separation has profound implications for performance, data management, and API design.</p> <p>Device Memory is optimized for the GPU's access patterns and computational model. It typically offers much higher bandwidth than system memory but may have different latency characteristics and access restrictions. Not all device memory is created equal \u2014 modern GPUs often provide several distinct memory types, each with specific performance characteristics and intended use cases.</p> <p>The boundary between host and device memory represents one of the primary bottlenecks in graphics applications. Transferring data across this boundary requires explicit coordination and can be orders of magnitude slower than accessing memory within the same domain. Understanding when and how to manage these transfers becomes essential for achieving optimal performance.</p>"},{"location":"01/Vulkan_SDK/#the-software-interface-apis-drivers-and-standards","title":"The Software Interface: APIs, Drivers, and Standards","text":"<p>Graphics APIs serve as the critical abstraction layer between application code and the underlying hardware diversity of the graphics ecosystem. They provide a standardized vocabulary for describing rendering operations, managing resources, and coordinating between the host and device systems.</p> <p>Vulkan represents a particular philosophy in this space \u2014 one that prioritizes explicit control and predictable behavior over ease of use. Unlike higher-level APIs that attempt to hide hardware complexity, Vulkan exposes the underlying realities of modern graphics hardware in a structured, manageable way.</p> <p>The Vulkan specification itself is maintained by the Khronos Group, an industry consortium that develops open standards for parallel computing, graphics, and related technologies. However, the specification is just that \u2014 a standard. The actual implementation that your application communicates with is provided by the GPU vendor's driver software.</p> <p>This distinction matters because it means that while Vulkan provides consistent behavior across platforms, the performance characteristics and optimization strategies may vary between vendors. NVIDIA's Vulkan driver may handle certain operations differently than AMD's or Intel's implementation, even though all three conform to the same specification.</p> <p>Our Vulkan development targets version 1.3 and above, which represents a mature iteration of the API with enhanced features for modern rendering techniques, improved developer tooling, and better cross-platform portability. These versions are supported across a wide range of platforms, from desktop operating systems like Windows and Linux to mobile platforms like Android, and even specialized environments like gaming consoles.</p>"},{"location":"01/Vulkan_SDK/#setting-up-the-development-environment","title":"Setting Up the Development Environment","text":"<p>Developing with Vulkan requires a complete SDK that includes not only the API headers and link libraries, but also validation layers, debugging tools, and utility applications. The de facto standard distribution is provided by LunarG, which packages the official Khronos Group components into platform-specific installers.</p> <p>The SDK can be obtained from LunarG's distribution portal and includes several essential components: the core API headers that define Vulkan's interface, validation layers that help catch programming errors during development, and diagnostic tools that can analyze performance and correctness.</p> <p></p> <p>One of the first steps after installation is verifying that your system's graphics hardware and drivers properly support Vulkan. The SDK includes a simple demonstration application \u2014 typically called <code>vkcube</code> \u2014 that renders a rotating cube using basic Vulkan operations. Successfully running this application confirms that your hardware drivers supports Vulkan runtime.</p> <p></p> <p>This verification step is more significant than it might initially appear. Vulkan's explicit design means that many configuration issues that would be silently handled by higher-level APIs will instead result in clear failures. A working <code>vkcube</code> demonstrates that the complex chain of SDK components, system drivers, and hardware capabilities are properly aligned \u2014 a necessary foundation for more sophisticated development work.</p> <p>Next Project Setup</p>"},{"location":"01/Window_Creation/","title":"Creating Windows and the Application Loop","text":"<p>With Vulkan instance creation complete, the next step is to create one or more application windows and set up the main loop. In VkLite, window management is fully abstracted: you can create as many windows as you like, and each can later be associated with its own swapchain and renderer.</p> <p>This chapter demonstrates how to use the <code>vklite::Context</code> API to create, manage, and destroy windows, and how to structure a basic application loop.</p>"},{"location":"01/Window_Creation/#creating-windows-self-contained-implementation","title":"Creating Windows (self-contained implementation)","text":"<p>This section contains full header and implementation code you can copy directly into your project. The goal is that a reader can follow the doc and build the example without opening the repository source files.</p> <p>Place the following header in <code>vklite/include/window.h</code>:</p> <pre><code>#pragma once\n\n#include &lt;string&gt;\n#include &lt;memory&gt;\n\n// Forward declare GLFWwindow to keep header light; implementation will include GLFW.\nstruct GLFWwindow;\n\nnamespace vklite {\n\nstruct Window {\n    void* handle = nullptr; // Will be GLFWwindow*\n    // Future: VkSurfaceKHR surface; VkSwapchainKHR swapchain; etc.\n    int width = 0;\n    int height = 0;\n    std::string title;\n};\n\n} // namespace vklite\n</code></pre> <p>Place the following implementation in <code>vklite/src/window.cpp</code>:</p> <pre><code>// window.cpp - window management implementation for vklite\n#include \"vklite.h\"\n#include \"window.h\"\n#include &lt;GLFW/glfw3.h&gt;\n#include &lt;vector&gt;\n\nnamespace vklite {\n\nWindow* Context::createWindow(int width, int height, const std::string&amp; title) {\n    GLFWwindow* win = glfwCreateWindow(width, height, title.c_str(), nullptr, nullptr);\n    if (!win) {\n        // Creation failed; surface-level errors can be retrieved by the application\n        // via the GLFW error callback if needed. Return nullptr to indicate failure.\n        return nullptr;\n    }\n    auto w = std::make_unique&lt;Window&gt;();\n    w-&gt;handle = win;\n    w-&gt;width = width;\n    w-&gt;height = height;\n    w-&gt;title = title;\n    windows.push_back(std::move(w));\n    return windows.back().get();\n}\n\nvoid Context::destroyWindow(Window* window) {\n    if (!window || !window-&gt;handle) return;\n    GLFWwindow* gw = static_cast&lt;GLFWwindow*&gt;(window-&gt;handle);\n    glfwDestroyWindow(gw);\n    window-&gt;handle = nullptr;\n    for (auto it = windows.begin(); it != windows.end(); ++it) {\n        if (it-&gt;get() == window) {\n            windows.erase(it);\n            break;\n        }\n    }\n}\n\nbool Context::isWindowOpen(const Window* window) const {\n    if (!window || !window-&gt;handle) return false;\n    return !glfwWindowShouldClose(static_cast&lt;GLFWwindow*&gt;(window-&gt;handle));\n}\n\nvoid Context::pollEvents() {\n    glfwPollEvents();\n}\n\nvoid Context::runMainLoop() {\n    while (true) {\n        pollEvents();\n        std::vector&lt;Window*&gt; toDestroy;\n        for (auto&amp; up : windows) {\n            Window* w = up.get();\n            if (w &amp;&amp; w-&gt;handle &amp;&amp; glfwWindowShouldClose(static_cast&lt;GLFWwindow*&gt;(w-&gt;handle))) {\n                toDestroy.push_back(w);\n            }\n        }\n        for (Window* w : toDestroy) destroyWindow(w);\n        if (windows.empty()) break;\n    }\n}\n\n} // namespace vklite\n</code></pre>"},{"location":"01/Window_Creation/#example-application","title":"Example application","text":"<p>Copy this minimal <code>sandbox/src/main.cpp</code> to see the windowing example in action:</p> <pre><code>#include \"vklite.h\"\n#include &lt;iostream&gt;\n\nint main() {\n        vklite::Context ctx;\n        if (!ctx.initialize(\"sandbox\")) {\n                std::cerr &lt;&lt; \"Failed to initialize vklite\\n\";\n                return 1;\n        }\n\n        auto* win1 = ctx.createWindow(800, 600, \"VkLite Window 1\");\n        auto* win2 = ctx.createWindow(640, 480, \"VkLite Window 2\");\n        if (!win1 || !win2) {\n                std::cerr &lt;&lt; \"Failed to create one or more windows\\n\";\n                ctx.shutdown();\n                return 1;\n        }\n\n        // Application is running; close windows to exit the loop.\n        ctx.runMainLoop();\n\n        ctx.shutdown();\n        return 0;\n}\n</code></pre>"},{"location":"01/Window_Creation/#the-application-loop","title":"The Application Loop","text":"<p>VkLite centralizes the application loop for you. The recommended approach is to call <code>ctx.runMainLoop()</code> which polls events and will return when all windows are closed. This keeps your application code concise and avoids accidental misuse of GLFW.</p>"},{"location":"01/Window_Creation/#cleanup","title":"Cleanup","text":"<p>When the loop exits, call <code>ctx.shutdown()</code> to destroy all windows and release resources:</p> <pre><code>ctx.shutdown();\n</code></pre>"},{"location":"01/Window_Creation/#full-example","title":"Full Example","text":"<pre><code>#include \"vklite.h\"\n#include &lt;iostream&gt;\n\nint main() {\n    vklite::Context ctx;\n    if (!ctx.initialize(\"sandbox\")) {\n        std::cerr &lt;&lt; \"Failed to initialize vklite\\n\";\n        return 1;\n    }\n\n    auto* win1 = ctx.createWindow(800, 600, \"VkLite Window 1\");\n    auto* win2 = ctx.createWindow(640, 480, \"VkLite Window 2\");\n    if (!win1 || !win2) {\n        std::cerr &lt;&lt; \"Failed to create one or more windows\\n\";\n        ctx.shutdown();\n        return 1;\n    }\n\n    // Application is running; close windows to exit the loop.\n\n    ctx.runMainLoop();\n\n    ctx.shutdown();\n    return 0;\n}\n</code></pre>"},{"location":"01/Window_Creation/#advanced-topics-where-the-code-lives","title":"Advanced topics &amp; where the code lives","text":"<p>This page focuses on window creation and the application loop using the <code>vklite</code> API. If you are interested in the Vulkan-side steps (surfaces, swapchains, render passes), those are advanced topics that are intentionally documented separately and implemented in their own modules.</p> <p>Where to look in the source:</p> <ul> <li><code>vklite/include/window.h</code> \u2014 the public <code>Window</code> struct and API types.</li> <li><code>vklite/src/window.cpp</code> \u2014 the implementation of <code>Context::createWindow</code>, <code>destroyWindow</code>, <code>isWindowOpen</code>, <code>pollEvents</code>, and <code>runMainLoop</code>.</li> </ul> <p>Recommended next docs:</p> <ul> <li>Instance creation and required instance extensions: Instance_Creation.md</li> <li>Swapchain &amp; rendering (planned): a separate guide that walks through creating <code>VkSurfaceKHR</code>, choosing formats/present modes, creating <code>VkSwapchainKHR</code>, and setting up a minimal render pass.</li> </ul> <p>If you'd like that swapchain guide authored here, I can create a dedicated <code>Swapchain.md</code> that uses your source examples as the canonical code for the tutorial.</p>"}]}